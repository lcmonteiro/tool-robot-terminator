#!/usr/bin/env python
###################################################################################################
### -                            {Terminal}                                                     ##-#
### -                                                                                          ##-#
### - Authors: Luis Monteiro                                                                   ##-#
###################################################################################################

###################################################################################################
# -------------------------------------------------------------------------------------------------
# imports
# -------------------------------------------------------------------------------------------------
###################################################################################################
# external
from subprocess import Popen, PIPE
from platform   import system
from os         import linesep
from threading  import Thread
from queue      import Queue, Empty
from ast        import literal_eval as evaluate 
from parse      import compile      as parser
from logging    import getLogger    as logger

# internal
from .translator import Translator

# #################################################################################################
# -------------------------------------------------------------------------------------------------
# Reader: 
# -------------------------------------------------------------------------------------------------
# #################################################################################################
class Reader:
    # #########################################################################
    # -------------------------------------------------------------------------
    # initialization
    # -------------------------------------------------------------------------
    def __init__(self, stream, timeout = 36000):
        self.__timeout = timeout
        self.__queue   = Queue()
        # create async task to read the stream
        self.__task = Thread(
            target = Reader.__populate, 
            args   = (self.__queue, stream),
            daemon = True)
        # start task
        self.__task.start()

    # #########################################################################
    # -------------------------------------------------------------------------
    # readline
    # -------------------------------------------------------------------------
    def readline(self):
        try:
            return self.__queue.get(timeout = self.__timeout)
        except Empty:
            return None

    # #########################################################################
    # -------------------------------------------------------------------------
    # readlines
    # -------------------------------------------------------------------------
    def readlines(self):
        while not self.__queue.empty():
            yield self.__queue.get()
    
    # #########################################################################
    # -------------------------------------------------------------------------
    # clear
    # -------------------------------------------------------------------------
    def clear(self):
        while not self.__queue.empty():
            self.__queue.get()

    # #########################################################################
    # -------------------------------------------------------------------------
    # populate
    # -------------------------------------------------------------------------
    @staticmethod
    def __populate(queue, stream):
        log = logger()
        for line in iter(stream.readline, b''):
            # process line
            line = line.decode().strip()
            # save line 
            queue.put(line)
            # log line
            log.debug(line)

# #################################################################################################
# -------------------------------------------------------------------------------------------------
# Mission Object
# -------------------------------------------------------------------------------------------------
# #################################################################################################
class Mission:
    # command template --------------------------------------
    _CMD = '({c}) && echo "{t}" || echo "{f}" {n}'

    # result  template --------------------------------------
    _RES = '--!!({c})==>>({{r}})??--'

    # #########################################################################
    # -------------------------------------------------------------------------
    # initialization
    # -------------------------------------------------------------------------
    def __init__(self, cmd):
        self.__res  = self._RES.format(c=cmd) 
        self.__line = self._CMD.format(
            c = cmd,
            t = self.__res.format(r=True ),
            f = self.__res.format(r=False),
            n = linesep)
        # plataform adaption
        if system() == 'Windows':
            self.__res  = f'"{self.__res}"' 

    # #########################################################################
    # -------------------------------------------------------------------------
    # command line
    # -------------------------------------------------------------------------
    def __bytes__(self):
        return self.__line.encode()

    # #########################################################################
    # -------------------------------------------------------------------------
    # Begin Monitor
    # -------------------------------------------------------------------------
    def begin(self):
        # Sentinel ------------------------------------------------------------
        class Begin:
            # initialization
            def __init__(self, line):
                self.__line = line.strip()
            # check
            def __eq__(self, line):
                return self.__line in line
        # create Sentinel -----------------------------------------------------
        return Begin(self.__line)

    # #########################################################################
    # -------------------------------------------------------------------------
    # End Monitor
    # -------------------------------------------------------------------------
    def end(self):
        # Sentinel ------------------------------------------------------------
        class End:
            # initialization
            def __init__(self, res):
                self.__parser = parser(res)
                self.__good = False
            # result
            def __bool__(self):
                return self.__good
            # check
            def __eq__(self, line):
                try:
                    self.__good = evaluate(
                        self.__parser.parse(line)['r'])
                    return True
                except:
                    return False
        # create Sentinel -----------------------------------------------------
        return End(self.__res)

###################################################################################################
# -------------------------------------------------------------------------------------------------
# Terminal Object
# -------------------------------------------------------------------------------------------------
###################################################################################################
class Terminal(object):
    __PATTERN = ""
    # #########################################################################
    # -------------------------------------------------------------------------
    # initialization
    # -------------------------------------------------------------------------
    def __init__(self, cwd=None):
        # select a context
        context = 'cmd' if system() == 'Windows' else 'sh' 
        # open a context
        self.__proc = Popen(context, 
            cwd=cwd, stdin=PIPE, stdout=PIPE, stderr=PIPE, bufsize=0)
        # create output pipe 
        self.__stdout = Reader(self.__proc.stdout) 
        self.__stderr = Reader(self.__proc.stderr) 
        # create a translator
        self.__translator = Translator(cwd)

    # #########################################################################
    # -------------------------------------------------------------------------
    # call
    # -------------------------------------------------------------------------
    def __call__(self, line, retries=0):
        # translate command line
        cmd = self.__translator.digest(line)
        # retries process
        count = 0
        while True:
            # step execute
            good, output = self.__execute(cmd)
            if good or retries <= count:
                return good, line, output
            count += 1

    # #########################################################################
    # -------------------------------------------------------------------------
    # delete
    # -------------------------------------------------------------------------
    def __del__(self):
        self.__proc.kill()

    # #########################################################################
    # -------------------------------------------------------------------------
    # execute
    # -------------------------------------------------------------------------
    def __execute(self, cmd):
        # build command 
        cmd, out, err = Mission(cmd), [], [] 
        # send command
        self.__proc.stdin.write(bytes(cmd))
        # plataform adaption
        if system() == 'Windows':
            # wait begin
            beg = cmd.begin()
            for _ in iter(self.__stdout.readline, beg): 
                pass
        # read output until end
        end = cmd.end()
        for l in iter(self.__stdout.readline, end):
            out += l.splitlines()
        # read errors
        for l in self.__stderr.readlines():
            err += l.splitlines()
        # return data
        return (bool(end), {'out': out, 'err': err})

###################################################################################################
# -------------------------------------------------------------------------------------------------
# End
# -------------------------------------------------------------------------------------------------
###################################################################################################
    